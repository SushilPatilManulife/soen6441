package eclipse_project;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;

public class UnfriendlyPlayer implements PlayerStrategy {

	public UnfriendlyPlayer(String name) {

	}

	@Override
	public void play(GameEngine gameEngine, Player player) {
		System.out.println("------------------------------------------------------------------------------------");
		//
		this.exchangeLanternCards(gameEngine, player);
		
		System.out.println("------------------------------------------------------------------------------------");
		//
		this.makeDedication(gameEngine, player);
		//
		this.placeLakeTile(gameEngine, player);
		// TODO pickup from stack
		
	}
	
	/**
	 * The goal is if possible is to get dedication tokens so someone else can't get it
	 * @param gameEngine
	 * @param player
	 */
	public void makeDedication(GameEngine gameEngine, Player player)
	{
		boolean played = false;
		//
		for(int i=0; i<gameEngine.PlayerList.size(); i++)
		{
			 if(player.playerLCStack.getSevenUniques()!=null && gameEngine.PlayerList.get(i).playerLCStack.getSevenUniques()!=null && gameEngine.dedicationTokens.sevenUniqueCount() == 1)
			 {
				 // make dedications
				 LanternCards sevenUniques = player.playerLCStack.getSevenUniques();
				 player.pickDedicationToken("sevenUnique", sevenUniques, gameEngine.lanternCards, gameEngine.dedicationTokens);
				 player.playerLCStack.withdrawAll(sevenUniques);
				 
				 //
				 System.out.println("unfriendly: doing seven unique to prevent user: "+gameEngine.PlayerList.get(i).name+" from doing seven unique");
				 
				 //
				 played=true;
				 break;
			 }else if(player.playerLCStack.getFourOfKinds()!=null && gameEngine.PlayerList.get(i).playerLCStack.getFourOfKinds() != null && gameEngine.dedicationTokens.fourOfKindCount() == 1)
			 {
				 // make dedications
				 LanternCards fourOfKind = player.playerLCStack.getFourOfKinds();
				 player.pickDedicationToken("FourOfKind", fourOfKind, gameEngine.lanternCards, gameEngine.dedicationTokens);
				 player.playerLCStack.withdrawAll(fourOfKind);
				 
				 //
				 System.out.println("unfriendly: doing four of kind to prevent user: "+gameEngine.PlayerList.get(i).name+" from four of kind");
				 
				 played=true;
				 break;
			 }else if(player.playerLCStack.getThreePairs()!=null && gameEngine.PlayerList.get(i).playerLCStack.getThreePairs()!=null && gameEngine.dedicationTokens.threePairCount() == 1)
			 {
				 // make dedications
				 LanternCards threePair = player.playerLCStack.getThreePairs();
				 player.pickDedicationToken("threePair", threePair, gameEngine.lanternCards, gameEngine.dedicationTokens);
				 player.playerLCStack.withdrawAll(threePair);
				 
				 //
				 System.out.println("unfriendly: doing three pair to prevent user: "+gameEngine.PlayerList.get(i).name+" from four of kind");
				 
				 played = true;
				 break;
			 }
		}
		
		if(!played)
		{
			System.out.println("unfriendly: no dedication possible that will prevent someone from making dedication");
		}
	}

	/**
	 * The goal is if possible  is to get a lantern card such that one of the players can't get a better score for the next round
	 * @param gameEngine contains the entire state of the game
	 * @param player current player
	 */
	public void exchangeLanternCards(GameEngine gameEngine, Player player)
	{
		if(player.favorTokenScore<2)
		{
			//
			System.out.println("unfriendly: can't do exchange lantern cards, not enough tokens: "+player.favorTokenScore);
		}
		
		// Available colors
		LinkedList<String> playerAvailableColors = player.playerLCStack.colorsWithAtLeastQuantity(1);
		if(playerAvailableColors.size() >= 1)
		{
			//
			System.out.println("unfriendly: can't do exchange lantern cards, player has no lantern cards ");
		}
		
		// Some cards are unique on the board, maybe someone needs them to make a dedication
		LinkedList<String> boardUniqueColors = gameEngine.lanternCards.colorsWithQuantity(1);
		//
		if(boardUniqueColors.size() == 0)
		{
			//
			System.out.println("unfriendly: no lantern cards on the board is unique, can't be unfriendly to any one");
			return;
		}
		
		
		//
		Player minPlayer = null;
		int minDedicationGain = Integer.MAX_VALUE;
		String minCardReturn = null;
		String minCardGet = null;
		
		//
		for(int i=0; i<playerAvailableColors.size(); i++)
		{
			//
			for(int j=0; j<boardUniqueColors.size(); j++)
			{
				//
				for(int k=0; k<gameEngine.PlayerList.size(); k++)
				{
					//
					if(gameEngine.PlayerList.get(k) == player)
						continue;

					//
					int gain = dedicationGain(gameEngine, gameEngine.PlayerList.get(k), playerAvailableColors.get(i), boardUniqueColors.get(j));
					
					if(gain < 0)
					{
						if(gain<minDedicationGain)
						{
							//
							minPlayer = gameEngine.PlayerList.get(k);
							minDedicationGain = gain;
							//
							minCardReturn = playerAvailableColors.get(i);
							minCardGet = boardUniqueColors.get(j);
						}
					}
				}
			}
		}
		
		if(minPlayer == null)
		{
			System.out.println("unfriendly: found no one who needed a single color to increase his dedication posibility");
		}else
		{
			System.out.println("unfriendly: being unfriendly to "+minPlayer.name+" returning lantern card "+minCardReturn+" getting lantern card"+minCardGet+", so he can't make dedication");
			player.spendFavorTokens(gameEngine.favorTokens, gameEngine.lanternCards, minCardReturn, minCardGet);
		}
		
	}

	/**
	 * What possible dedications does the player gain if he gets lantern color2 instead of lantern color2
	 * @param player
	 * @param color1
	 * @param color2
	 * @return
	 */
	public int dedicationGain(GameEngine gameEngine, Player player, String color1, String color2)
	{
		// current players lantern cards
		LanternCards lanternCardWithColor1 = player.getLanternCards().duplicate();
		lanternCardWithColor1.addCard(color1);
		
		// current players lantern cards
		LanternCards lanternCardWithColor2 = player.getLanternCards().duplicate();
		lanternCardWithColor2.addCard(color2);
		
		// 
		return lanternCardWithColor2.possibleDedicationsCount(gameEngine.dedicationTokens) - lanternCardWithColor2.possibleDedicationsCount(gameEngine.dedicationTokens);
	}


	/**
	 * The goal is to place a lake tiles such that it minimizes the possible score gain on any given player
	 * @param gameEngine
	 * @param player
	 * @param br
	 * @throws NumberFormatException
	 * @throws IOException
	 */
	public void placeLakeTile(GameEngine gameEngine, Player player) 
	{
		//
		System.out.println("unfriendly player:  "+player.name+" is about to place a lake tile");
		
		//
		if(player.playerLTStack.size() == 0)
		{
			System.out.println("No lake tile available to play");
			return;
		}
		
		// The  lake tile position with the min benefit case of a given player
		int[] minPosition = null; // the position leading to a min point for a given player
		int minRotation = 0;   	  // the rotation of the min point localtion
		int minDedicationGain = Integer.MAX_VALUE; 	 	// The min points I can make any given player have
		int minId = 0; 			// An id of a lake tile adjacent to the min position
		Player minPlayer = null;
		String minReason = "";
		
		// empty location
		ArrayList<int[]> emptyLocations = gameEngine.board.availableSpacesPosition();
		
		
		//foreach of the character laketiles
		ArrayList<LakeTiles> lakeTiles = player.getLakeTiles(); 
		for(int i=0; i<lakeTiles.size(); i++)
		{
			//
			LakeTiles lakeTile = lakeTiles.get(i);
		
			// for each of the possible locations
			for(int j=0; i<emptyLocations.size(); j++)
			{
				//
				int[] position = emptyLocations.get(j);
				
				// Go through the possible rotations
				int[] possibleRotations = new int[]{0, 90, 180, 270};
				for(int k=0; i<possibleRotations.length; k++)
				{
					//
					int rotation = possibleRotations[k];
					
					// for each of the other players
					for(int z=0; z<gameEngine.PlayerList.size(); z++)
					{
						//
						Player currentPlayer = gameEngine.PlayerList.get(z);
						
						//TODO test
						if(currentPlayer != player)
						{
							// obtained color
							String color = lakeTile.positionRotated(currentPlayer.boardPosition, rotation);
							// 
							int dedicationGain_ = dedicationGain(gameEngine, currentPlayer, color+"Card");
				
							//
							boolean isMin  = false;
							boolean end = false;

							// player will not be able to get card
							if(!gameEngine.lanternCards.hasCard(color+"Card"))
							{
								isMin = true;
								end = true;
								minReason = " prevent player from getting card: "+color;
							}else if(minPosition == null || dedicationGain_ < minDedicationGain)
							{//TODO all players
								isMin = true;
								end = false;
								minReason = " player has not score gain with card: "+color;
							}
							
							
							// place lake tile such that minimizes the score gained
							if(isMin)
							{
								//
								minPosition = position;
								minRotation = rotation;
								minDedicationGain = dedicationGain_;
								minId = lakeTile.id;
								minPlayer = currentPlayer;
							}
							
							if(end)
							{
								break;
							}
						}
					}
				}
			}
		}
		
		//
		System.out.println("Unfriendly: placing laketile: "+minId+", min_player(victim): "+minPlayer.name+", min position: "+minPosition+" reason: "+minReason);
		//  widraw lake tile
		LakeTiles currentTileToPlace = player.placeLakeTile(minId);
		//
		gameEngine.lakeTiles.rotateLakeTile(currentTileToPlace, minRotation);
		//
		boolean placedLaketile = gameEngine.lakeTiles.placeTile(minPosition[1], minPosition[0], gameEngine.board, currentTileToPlace);
		
		// TODO test distribute
		if(placedLaketile)
		{
			System.out.println("unfriendly:  assigning lake tiles to players");
			// 
			gameEngine.lanternCards.assignLanternCardsToPlayers(
					gameEngine.numOfPlayer, gameEngine.board,
					minPosition[1],minPosition[0], currentTileToPlace,
						gameEngine.PlayerList, gameEngine.lanternCards, gameEngine.favorTokens);
			//
		}else
		{
			System.out.println("unfriendly: Unexpected error placing lake tile");
		}
	}
	

	
	/**
	 * What possible dedications does the player if he gets the lanternCard of given color?
	 * @param gameEngine
	 * @param lakeTile
	 * @param player
	 * @param position
	 * @param rotation
	 * @return
	 */
	public int dedicationGain(GameEngine gameEngine, Player player, String cardColor)
	{
		// current players lantern cards
		LanternCards lanternCards = player.getLanternCards();
		int current = lanternCards.possibleDedicationsCount(gameEngine.dedicationTokens);
		
		// lantern cards of player after tile is placed
		LanternCards lanternAfterCard = lanternCards.duplicate();
		lanternAfterCard.addCard(cardColor);
		
		//
		int afterLakeTile = lanternAfterCard.possibleDedicationsCount(gameEngine.dedicationTokens);
		
		// 
		return afterLakeTile - current;
	}
}
